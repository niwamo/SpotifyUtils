<#
.SYNOPSIS
Adds songs to your Spotify liked tracks

.DESCRIPTION
Accepts a list of tracks from a CSV or from another cmdlet in this module,
searches for those songs on Spotify, and adds them to your Spotify liked tracks
if found.

.PARAMETER Tracks
Mutually exclusive with InputFile. An array of SpotifyTracks, as generated by
another cmdlet in this module, such as Get-TracksFromFolder or
Get-SpotifyTracks.

.PARAMETER InputFile
Mutually exclusive with Tracks. The Path to a CSV file containing a list of
tracks, where each track has values for three columns: name (song name), artists
(a comma-separated list of artist names), and album (album name).

.PARAMETER ClientId
Optional. The ClientId of the app you registered in the Spotify developer
portal. See the 'Authentication' section at
https://github.com/niwamo/SpotifyUtils

.PARAMETER RedirectURI
Optional. The redirect URI used for OAuth authentication. Must match what is
configured in the Spotify developer protal. See the 'Authentication' section at
https://github.com/niwamo/SpotifyUtils

.PARAMETER ConfigFile
Optional. The path to a JSON configuration file containing 'ClientId' and
'RedirectURI' properties. See the 'Authentication' section at
https://github.com/niwamo/SpotifyUtils

.EXAMPLE
Add-SpotifyTracks -Tracks $(Get-TracksFromFolder -Path ~\Songs)
#>
function Add-SpotifyTracks {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$false, ValueFromPipeline=$true, Position=0)]
        [Object[]] $Tracks,

        [ValidateScript({ Test-Path $_ })]
        [Parameter(Mandatory=$false)]
        [string] $InputFile,

        [Parameter(Mandatory=$false)]
        [string] $ClientId,

        [Parameter(Mandatory=$false)]
        [string] $RedirectURI,

        [ValidateScript({Test-Path $_})]
        [Parameter(Mandatory=$false)]
        [string] $ConfigFile
    )
    
    begin {
        Set-StrictMode -Version 1.0
        $ErrorActionPreference = 'Stop'
        $inputData = [System.Collections.ArrayList]::new()
    }

    process {
        if (!$Tracks -and !$InputFile) {
            throw "Either 'Tracks' or 'InputFile' required"
        }
        elseif ($Tracks) {
            $inputData.AddRange([array] $Tracks) | Out-Null
        }
        elseif ($InputFile.Substring($InputFile.Length-3, 3) -ne 'csv') {
            throw 'Only CSV files are supported for InputFile'
        }
        else {
            Write-Debug "Importing tracks from CSV"
            $inputData = Import-Csv -Path $InputFile
        }
    }
  
    end {
        Write-Debug (
            "Received $($inputData.Count) tracks to add"
        )
        $tracks = ConvertTo-SpotifyTrack -Tracks $inputData
        
        # authorization
        $TokenParams = @{
            Scopes = @('user-library-modify')
        }
        foreach ($param in @('ClientId', 'RedirectURI', 'ConfigFile')) {
            if ($PSBoundParameters.ContainsKey($param)) {
                $TokenParams.Add($param, $PSBoundParameters.TryGetValue($param))
            }
        }
        try {
            $token = Get-SpotifyToken @TokenParams
        }
        catch {
            Write-Error (
                "There was a problem authenticating to the Spotify API.`n" +
                "Please review the Authentication section at https://github.com/niwamo/SpotifyUtils.`n" +
                "Error message: " + $_.Exception.Message
            )
        }
        $headers = @{ Authorization = "Bearer $token" }

        ##########################
        # Region: Add Tracks     #
        ##########################

        $missing = [System.Collections.ArrayList]::new()
        foreach ($song in $tracks) {
            # https://stackoverflow.com/questions/73680222
            $uri = [string]::Format(
                "{0}?type=track&q=artist:""{1}"" track:""{2}""",
                $script:SEARCH_URI, $song.artists[0], $song.name
            )
            $results = (
                Invoke-WebRequest -Uri $uri -Headers $headers
            ).Content | ConvertFrom-Json
            $match = $false
            if ($results.tracks.items -and $results.tracks.items.Count -gt 0) {
                $top = $results.tracks.items[0]
                $match = $true  # assume true, set to false if any comparisons fail
                $comparisons = @(
                    @($song.name, $top.name),
                    @($song.artists[0], $top.artists[0].name)
                )
                foreach ($set in $comparisons) {
                    $cmp1, $cmp2 = $set
                    $len = [math]::min($cmp1.Length, $cmp2.Length)
                    $match = $cmp1.Substring(0, $len) -eq $cmp2.Substring(0, $len)
                    if (! $match) { break }
                }
            }
            if ($match) {
                $params = @{
                    URI         = "$script:MYTRACKS_URI"
                    Method      = 'Put'
                    ContentType = 'application/json'
                    Body        = "{""ids"":[""$($top.id)""]}"
                    Headers     = $headers
                }
                Invoke-WebRequest @params | Out-Null
                Write-Debug "Added $($song.name)"
            }
            else {
                $songInfo = [string]::Format(
                    "    song.name: {0}, song.artists[0]: {1}",
                    $song.name, $song.artists[0]
                )
                $topInfo = if ($results.tracks.items) {
                    [string]::Format(
                        "    top.name: {0}, top.artists[0].name: {1}",
                        $top.name, $top.artists[0].name
                    )
                } else { "    search results were null" }
                $logMessage = [string]::Format(
                    "Could not find {0}`n{1}`n{2}", $song.name, $songInfo, $topInfo
                )
                Write-Debug $logMessage
                $missing.Add($song) | Out-Null
            }

            [System.Threading.Thread]::Sleep($script:API_DELAY)
        }

        if ($missing.Count) {
            Write-Warning "Failed to add $($missing.Count) tracks, returning them in an array"
            return $missing
        }
    }
}
